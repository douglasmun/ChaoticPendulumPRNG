<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Enhanced Chaotic Pendulum PRNG</title>
  <style>
    :root {
      --neon-blue: #0ff;
      --neon-pink: #f0f;
      --neon-green: #0f0;
      --neon-purple: #9457eb;
      --neon-orange: #ff8c00;
      --dark-bg: #111;
      --darker-bg: #080808;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Courier New', monospace;
      background: var(--darker-bg);
      color: #fff;
      padding: 1em;
      min-height: 100vh;
      overflow-x: hidden;
    }
    
    .container {
      max-width: 1600px;
      margin: 0 auto;
    }
    
    header {
      text-align: center;
      margin-bottom: 1.5rem;
    }
    
    h1 {
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
      text-shadow: 0 0 10px var(--neon-blue), 0 0 20px var(--neon-blue);
      color: var(--neon-blue);
      letter-spacing: 2px;
    }
    
    .subtitle {
      color: var(--neon-green);
      margin-bottom: 1.5rem;
      font-size: 1.1rem;
      text-shadow: 0 0 5px var(--neon-green);
      max-width: 900px;
      margin-left: auto;
      margin-right: auto;
      line-height: 1.5;
    }
    
    h2 {
      font-size: 1.2rem;
      margin-bottom: 0.5rem;
      color: var(--neon-pink);
      text-shadow: 0 0 5px var(--neon-pink);
    }
    
    .dashboard {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 1.5rem;
    }
    
    @media (max-width: 900px) {
      .dashboard {
        grid-template-columns: 1fr;
      }
    }
    
    .stat-box {
      background: var(--dark-bg);
      border: 1px solid var(--neon-purple);
      border-radius: 5px;
      padding: 12px;
      box-shadow: 0 0 10px var(--neon-purple);
    }
    
    #controls {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      align-items: center;
      margin-bottom: 1.5rem;
      padding: 15px;
      background: var(--dark-bg);
      border: 1px solid var(--neon-green);
      border-radius: 5px;
      box-shadow: 0 0 10px var(--neon-green);
    }
    
    label {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--neon-green);
      font-size: 0.9rem;
    }
    
    input[type="range"] {
      width: 120px;
      accent-color: var(--neon-green);
    }
    
    button {
      background: var(--dark-bg);
      color: var(--neon-blue);
      border: 1px solid var(--neon-blue);
      border-radius: 4px;
      padding: 6px 12px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
      transition: all 0.3s;
      box-shadow: 0 0 5px var(--neon-blue);
    }
    
    button:hover {
      background: rgba(0, 255, 255, 0.1);
      box-shadow: 0 0 15px var(--neon-blue);
    }
    
    #canvas-container {
      position: relative;
      width: 100%;
      margin-bottom: 1.5rem;
      border: 1px solid var(--neon-pink);
      border-radius: 5px;
      overflow: hidden;
      box-shadow: 0 0 15px var(--neon-pink);
      min-height: 500px;
      height: 60vh;
      background: var(--dark-bg);
    }
    
    #pendulumCanvas {
      width: 100%;
      height: 100%;
      display: block;
      background: transparent;
    }
    
    .output-section {
      margin-bottom: 1.5rem;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    
    @media (max-width: 900px) {
      .output-section {
        grid-template-columns: 1fr;
      }
    }
    
    .output-column {
      background: var(--dark-bg);
      border: 1px solid var(--neon-purple);
      border-radius: 5px;
      padding: 15px;
      box-shadow: 0 0 10px var(--neon-purple);
    }
    
    #outputGrid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
      gap: 6px;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .byte {
      font-family: monospace;
      text-align: center;
      padding: 4px;
      background: rgba(148, 87, 235, 0.1);
      border-radius: 3px;
      color: var(--neon-purple);
      text-shadow: 0 0 2px var(--neon-purple);
      font-size: 0.85rem;
    }
    
    #heatmap {
      width: 100%;
      height: 300px;
      display: grid;
      grid-template-columns: repeat(17, 1fr);
      grid-template-rows: repeat(17, 1fr);
      gap: 1px;
      background: var(--dark-bg);
      border-radius: 5px;
      padding: 5px;
    }
    
    .heatmap-cell {
      background: #111;
      border-radius: 2px;
      transition: all 0.3s ease;
      position: relative;
    }
    
    .heatmap-label {
      background: transparent;
      color: rgba(255, 255, 255, 0.7);
      font-size: 0.7rem;
      display: flex;
      align-items: center;
      justify-content: center;
      border: none;
    }
    
    .instructions {
      position: absolute;
      bottom: 10px;
      left: 10px;
      color: rgba(255, 255, 255, 0.7);
      font-size: 0.8rem;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      border-radius: 4px;
      pointer-events: none;
    }
    
    .mouse-force-indicator {
      position: absolute;
      top: 10px;
      right: 10px;
      color: var(--neon-green);
      font-size: 0.9rem;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      border-radius: 4px;
      display: none;
    }
    
    .stat-value {
      font-size: 1rem;
      color: var(--neon-blue);
      text-shadow: 0 0 5px var(--neon-blue);
      margin: 8px 0;
    }
    
    .chart-container {
      height: 60px;
      position: relative;
    }
    
    .chart-bar {
      height: 30px;
      border-radius: 3px;
      position: relative;
      transition: all 0.3s ease;
    }
    
    .chart-text {
      position: absolute;
      top: 35px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.8rem;
      color: var(--neon-green);
    }
    
    /* Fire effect for heatmap */
    @keyframes fire-flicker {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.7; transform: scale(1.05); }
    }
    
    .fire-hot {
      animation: fire-flicker 0.5s infinite alternate;
      box-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
    }
    
    .fire-warm {
      animation: fire-flicker 1s infinite alternate;
      box-shadow: 0 0 4px rgba(255, 204, 0, 0.4);
    }
    
    .fire-medium {
      animation: fire-flicker 1.5s infinite alternate;
      box-shadow: 0 0 2px rgba(255, 102, 0, 0.3);
    }
    
    .pendulum-trail {
      opacity: 0.6;
      stroke-width: 1;
    }
    
    /* Glow effects */
    .glow {
      filter: drop-shadow(0 0 3px currentColor);
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>ðŸŒ€ Enhanced Chaotic Pendulum PRNG</h1>
      <div class="subtitle">
        Advanced pseudo-random number generator using chaotic double pendulum motion arranged in a 2x4 grid.
        Move your mouse near the pendulums to introduce entropy and influence their rapid chaotic motion.
      </div>
    </header>
    
    <div class="dashboard">
      <div class="stat-box">
        <h2>System Entropy</h2>
        <div class="chart-container">
          <div id="entropyBar" class="chart-bar" style="background: linear-gradient(90deg, var(--neon-blue), var(--neon-purple)); width: 0%;">
            <div id="entropyText" class="chart-text">0.0000 bits</div>
          </div>
        </div>
      </div>
      <div class="stat-box">
        <h2>Bit Distribution</h2>
        <div class="chart-container">
          <div style="display: flex; height: 30px;">
            <div id="zerosBar" class="chart-bar" style="background: var(--neon-pink); flex: 1; margin-right: 2px;"></div>
            <div id="onesBar" class="chart-bar" style="background: var(--neon-green); flex: 1; margin-left: 2px;"></div>
          </div>
          <div id="biasText" class="chart-text">0s: 0 (50%), 1s: 0 (50%)</div>
        </div>
      </div>
    </div>
    
    <div id="controls">
      <label>Seed: <input type="range" id="seedSlider" min="0" max="100" value="50" /></label>
      <label>Force: <input type="range" id="forceSlider" min="1" max="100" value="30" /></label>
      <label>Speed: <input type="range" id="speedSlider" min="1" max="10" value="5" /></label>
      <button id="resetBtn">ðŸ”„ Reset</button>
      <button id="exportBtn">ðŸ“‹ Export</button>
    </div>
    
    <div id="canvas-container">
      <svg id="pendulumCanvas"></svg>
      <div class="instructions">Move mouse near pendulums for entropy â€¢ 2x4 grid layout</div>
      <div class="mouse-force-indicator" id="forceIndicator">Force: 0</div>
    </div>
    
    <div class="output-section">
      <div class="output-column">
        <h2>Generated Values (hex)</h2>
        <div id="outputGrid"></div>
      </div>
      <div class="output-column">
        <h2>Distribution Heatmap</h2>
        <div id="heatmap"></div>
      </div>
    </div>
  </div>

  <script>
    class ChaoticPendulum {
      constructor(seedOffset, xOrigin, yOrigin) {
        this.theta1 = Math.PI / 2 + seedOffset * 0.02;
        this.theta2 = Math.PI / 2 - seedOffset * 0.02;
        this.omega1 = (Math.random() - 0.5) * 2;
        this.omega2 = (Math.random() - 0.5) * 2;
        this.length1 = 80;
        this.length2 = 80;
        this.mass1 = 1;
        this.mass2 = 1;
        this.g = 15; // Increased gravity for faster motion
        this.origin = { x: xOrigin, y: yOrigin };
        this.externalForce = { x: 0, y: 0 };
        this.damping = 0.9995; // Very light damping
        this.trail = [];
        this.maxTrailLength = 20;
      }

      applyExternalForce(forceX, forceY) {
        this.externalForce.x = forceX * 0.5;
        this.externalForce.y = forceY * 0.5;
      }

      step(dt) {
        // Apply external force
        const forceMagnitude = Math.sqrt(this.externalForce.x * this.externalForce.x + 
                                        this.externalForce.y * this.externalForce.y);
        
        if (forceMagnitude > 0) {
          const torque1 = -this.length1 * (this.externalForce.x * Math.cos(this.theta1) - 
                                          this.externalForce.y * Math.sin(this.theta1));
          const torque2 = -this.length2 * (this.externalForce.x * Math.cos(this.theta2) - 
                                          this.externalForce.y * Math.sin(this.theta2));
          
          this.omega1 += torque1 * dt * 2 / (this.mass1 * this.length1 * this.length1);
          this.omega2 += torque2 * dt * 2 / (this.mass2 * this.length2 * this.length2);
          
          this.externalForce.x = 0;
          this.externalForce.y = 0;
        }
        
        // Enhanced double pendulum physics
        const dtheta1 = this.omega1;
        const dtheta2 = this.omega2;
        
        const cosDelta = Math.cos(this.theta2 - this.theta1);
        const sinDelta = Math.sin(this.theta2 - this.theta1);
        
        const denom1 = (this.mass1 + this.mass2) * this.length1 - 
                      this.mass2 * this.length1 * cosDelta * cosDelta;
        const denom2 = (this.mass1 + this.mass2) * this.length2 - 
                      this.mass2 * this.length2 * cosDelta * cosDelta;
        
        const domega1 = (
          -this.g * (this.mass1 + this.mass2) * Math.sin(this.theta1) -
          this.mass2 * this.g * Math.sin(this.theta1 - 2 * this.theta2) -
          2 * sinDelta * this.mass2 * (
            this.omega2 * this.omega2 * this.length2 +
            this.omega1 * this.omega1 * this.length1 * cosDelta
          )
        ) / (this.length1 * denom1);
        
        const domega2 = (
          2 * sinDelta * (
            this.omega1 * this.omega1 * this.length1 * (this.mass1 + this.mass2) +
            this.g * (this.mass1 + this.mass2) * Math.cos(this.theta1) +
            this.omega2 * this.omega2 * this.length2 * this.mass2 * cosDelta
          )
        ) / (this.length2 * denom2);
        
        // Add some chaos
        const chaos = 0.01;
        this.omega1 += (Math.random() - 0.5) * chaos;
        this.omega2 += (Math.random() - 0.5) * chaos;
        
        this.theta1 += dtheta1 * dt;
        this.omega1 += domega1 * dt;
        this.theta2 += dtheta2 * dt;
        this.omega2 += domega2 * dt;
        
        // Apply damping
        this.omega1 *= this.damping;
        this.omega2 *= this.damping;
        
        // Update trail
        const pos = this.getTipPosition();
        this.trail.push({ x: pos.x2, y: pos.y2 });
        if (this.trail.length > this.maxTrailLength) {
          this.trail.shift();
        }
      }

      getTipPosition() {
        const x1 = this.origin.x + this.length1 * Math.sin(this.theta1);
        const y1 = this.origin.y + this.length1 * Math.cos(this.theta1);
        const x2 = x1 + this.length2 * Math.sin(this.theta2);
        const y2 = y1 + this.length2 * Math.cos(this.theta2);
        return { x1, y1, x2, y2 };
      }

      extractBit() {
        try {
          const { x2, y2 } = this.getTipPosition();
          const combined = Math.abs(x2 * 1000 + y2 * 1000 + this.omega1 * 10000 + this.omega2 * 10000);
          const str = combined.toFixed(10).replace('.', '');
          const digit = parseInt(str[str.length - 1] || '0');
          return digit % 2;
        } catch (error) {
          return Math.random() > 0.5 ? 1 : 0;
        }
      }
    }

    class ChaoticPRNG {
      constructor(seedOffset = 50) {
        this.pendulums = [];
        this.seedOffset = seedOffset;
        this.sampleCounter = 0;
        this.sampleRate = 8; // Slower sampling
        this.initializePendulums();
      }

      initializePendulums() {
        try {
          const container = document.getElementById('canvas-container');
          const containerWidth = container.clientWidth;
          const containerHeight = container.clientHeight;
          
          // 2x4 grid layout
          const cols = 4;
          const rows = 2;
          const spacingX = containerWidth / (cols + 1);
          const spacingY = containerHeight / (rows + 1);
          
          this.pendulums = [];
          for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
              const x = spacingX * (col + 1);
              const y = spacingY * (row + 1);
              const index = row * cols + col;
              this.pendulums.push(new ChaoticPendulum(
                index + this.seedOffset * 0.1, x, y
              ));
            }
          }
        } catch (error) {
          console.error("Error initializing pendulums:", error);
        }
      }

      stepAll(dt) {
        this.pendulums.forEach(p => p.step(dt));
      }

      generateByte() {
        try {
          // Only generate byte at reduced sample rate
          this.sampleCounter++;
          if (this.sampleCounter < this.sampleRate) {
            return null;
          }
          this.sampleCounter = 0;
          
          const bits = this.pendulums.map(p => p.extractBit());
          return parseInt(bits.join(''), 2);
        } catch (error) {
          console.error("Error generating byte:", error);
          return Math.floor(Math.random() * 256);
        }
      }

      getPendulumPositions() {
        return this.pendulums.map(p => ({
          ...p.getTipPosition(),
          trail: [...p.trail]
        }));
      }

      updateSeedOffset(offset) {
        this.seedOffset = offset;
        this.pendulums.forEach((p, i) => {
          p.theta1 = Math.PI / 2 + (i + offset * 0.1) * 0.02;
          p.theta2 = Math.PI / 2 - (i + offset * 0.1) * 0.02;
          p.omega1 = (Math.random() - 0.5) * 2;
          p.omega2 = (Math.random() - 0.5) * 2;
        });
      }

      applyMouseForce(mouseX, mouseY, forceFactor) {
        let maxForce = 0;
        this.pendulums.forEach(pendulum => {
          const pos = pendulum.getTipPosition();
          const dx = mouseX - pos.x2;
          const dy = mouseY - pos.y2;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 200) {
            const force = forceFactor * (1 - distance / 200);
            maxForce = Math.max(maxForce, force);
            const forceX = (dx / (distance || 1)) * force;
            const forceY = (dy / (distance || 1)) * force;
            pendulum.applyExternalForce(forceX, forceY);
          }
        });
        
        if (maxForce > 0) {
          document.getElementById('forceIndicator').style.display = 'block';
          document.getElementById('forceIndicator').textContent = `Force: ${maxForce.toFixed(2)}`;
        }
      }
    }

    // Application state
    let prng;
    const outputList = [];
    const valueCounts = new Array(256).fill(0);
    let svg;
    let animationFrameId;
    let speedMultiplier = 1;

    function initApplication() {
      try {
        const seedOffset = parseInt(document.getElementById("seedSlider").value);
        prng = new ChaoticPRNG(seedOffset);
        
        const container = document.getElementById("canvas-container");
        svg = document.getElementById("pendulumCanvas");
        svg.setAttribute("width", container.clientWidth);
        svg.setAttribute("height", container.clientHeight);
        
        initHeatmap();
        setupEventListeners();
        
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        update();
        
        console.log("Application initialized successfully!");
      } catch (error) {
        console.error("Error initializing application:", error);
      }
    }

    function initHeatmap() {
      const heatmapDiv = document.getElementById("heatmap");
      heatmapDiv.innerHTML = '';
      
      // Create 17x17 grid (16x16 for values + 1 row/col for labels)
      const gridSize = 16;
      
      // Add empty corner cell
      const corner = document.createElement('div');
      corner.className = 'heatmap-label';
      heatmapDiv.appendChild(corner);
      
      // Column labels
      for (let i = 0; i < 16; i++) {
        const label = document.createElement('div');
        label.className = 'heatmap-label';
        label.textContent = i.toString(16).toUpperCase();
        heatmapDiv.appendChild(label);
      }
      
      // Rows with row labels and data cells
      for (let row = 0; row < 16; row++) {
        // Row label
        const label = document.createElement('div');
        label.className = 'heatmap-label';
        label.textContent = row.toString(16).toUpperCase();
        heatmapDiv.appendChild(label);
        
        // Data cells
        for (let col = 0; col < 16; col++) {
          const cell = document.createElement('div');
          cell.className = 'heatmap-cell';
          cell.id = `cell-${row * 16 + col}`;
          cell.setAttribute('data-value', row * 16 + col);
          cell.setAttribute('data-count', 0);
          heatmapDiv.appendChild(cell);
        }
      }
    }

    function updateHeatmap() {
      const maxCount = Math.max(...valueCounts, 1);
      
      for (let i = 0; i < 256; i++) {
        const cell = document.getElementById(`cell-${i}`);
        if (cell) {
          const count = valueCounts[i];
          const intensity = count / maxCount;
          
          // Remove existing fire classes
          cell.classList.remove('fire-hot', 'fire-warm', 'fire-medium');
          
          if (intensity === 0) {
            cell.style.backgroundColor = '#111';
          } else {
            // Fire-like color progression
            let color;
            if (intensity < 0.2) {
              const t = intensity * 5;
              color = `rgb(${Math.floor(51 + 153 * t)}, 0, 0)`;
            } else if (intensity < 0.5) {
              const t = (intensity - 0.2) * 3.33;
              color = `rgb(${Math.floor(204 + 51 * t)}, ${Math.floor(102 * t)}, 0)`;
            } else if (intensity < 0.8) {
              const t = (intensity - 0.5) * 3.33;
              color = `rgb(255, ${Math.floor(102 + 102 * t)}, 0)`;
            } else {
              const t = (intensity - 0.8) * 5;
              color = `rgb(255, ${Math.floor(204 + 51 * t)}, ${Math.floor(255 * t)})`;
            }
            
            cell.style.backgroundColor = color;
            
            // Add fire animation classes
            if (intensity > 0.8) {
              cell.classList.add('fire-hot');
            } else if (intensity > 0.5) {
              cell.classList.add('fire-warm');
            } else if (intensity > 0.2) {
              cell.classList.add('fire-medium');
            }
          }
          
          cell.setAttribute('data-count', count);
        }
      }
    }

    function setupEventListeners() {
      document.getElementById("seedSlider").addEventListener("input", e => {
        prng.updateSeedOffset(+e.target.value);
      });
      
      document.getElementById("speedSlider").addEventListener("input", e => {
        speedMultiplier = parseInt(e.target.value);
      });
      
      document.getElementById("resetBtn").addEventListener("click", () => {
        outputList.length = 0;
        valueCounts.fill(0);
        renderOutput();
        updateHeatmap();
        updateStats();
        prng.updateSeedOffset(parseInt(document.getElementById("seedSlider").value));
      });
      
      document.getElementById("exportBtn").addEventListener("click", () => {
        try {
          const blob = new Blob([outputList.join('\n')], { type: 'text/plain' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "enhanced_prng_output.txt";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        } catch (error) {
          console.error("Error exporting data:", error);
        }
      });
      
      document.getElementById("canvas-container").addEventListener("mousemove", e => {
        const rect = e.target.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        const forceFactor = parseInt(document.getElementById("forceSlider").value) / 5;
        prng.applyMouseForce(mouseX, mouseY, forceFactor);
      });
      
      document.getElementById("canvas-container").addEventListener("mouseleave", () => {
        document.getElementById('forceIndicator').style.display = 'none';
      });
      
      window.addEventListener("resize", () => {
        const container = document.getElementById("canvas-container");
        svg.setAttribute("width", container.clientWidth);
        svg.setAttribute("height", container.clientHeight);
        prng.initializePendulums();
      });
    }

    function update() {
      try {
        // Step pendulums at higher speed
        for (let i = 0; i < speedMultiplier; i++) {
          prng.stepAll(0.016); // ~60fps base rate
        }
        
        // Generate byte at controlled rate
        const byte = prng.generateByte();
        if (byte !== null) {
          outputList.push(byte);
          valueCounts[byte]++;
          
          if (outputList.length > 2000) {
            const removed = outputList.splice(0, 200);
            removed.forEach(val => valueCounts[val] = Math.max(0, valueCounts[val] - 1));
          }
          
          renderOutput();
          updateHeatmap();
          updateStats();
        }
        
        renderPendulums();
        animationFrameId = requestAnimationFrame(update);
      } catch (error) {
        console.error("Error in update loop:", error);
      }
    }

    function renderPendulums() {
      try {
        const positions = prng.getPendulumPositions();
        svg.innerHTML = '';
        
        // Create glow filter
        const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        const filter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
        filter.setAttribute("id", "glow");
        
        const blur = document.createElementNS("http://www.w3.org/2000/svg", "feGaussianBlur");
        blur.setAttribute("stdDeviation", "2");
        blur.setAttribute("result", "coloredBlur");
        
        const merge = document.createElementNS("http://www.w3.org/2000/svg", "feMerge");
        const mergeNode1 = document.createElementNS("http://www.w3.org/2000/svg", "feMergeNode");
        mergeNode1.setAttribute("in", "coloredBlur");
        const mergeNode2 = document.createElementNS("http://www.w3.org/2000/svg", "feMergeNode");
        mergeNode2.setAttribute("in", "SourceGraphic");
        
        merge.appendChild(mergeNode1);
        merge.appendChild(mergeNode2);
        filter.appendChild(blur);
        filter.appendChild(merge);
        defs.appendChild(filter);
        svg.appendChild(defs);
        
        positions.forEach((pos, i) => {
          const pendulum = prng.pendulums[i];
          const hue = (i * 45) % 360;
          const color = `hsl(${hue}, 80%, 60%)`;
          
          // Draw trail
          if (pos.trail.length > 1) {
            for (let j = 1; j < pos.trail.length; j++) {
              const alpha = j / pos.trail.length * 0.5;
              const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
              line.setAttribute("x1", pos.trail[j-1].x);
              line.setAttribute("y1", pos.trail[j-1].y);
              line.setAttribute("x2", pos.trail[j].x);
              line.setAttribute("y2", pos.trail[j].y);
              line.setAttribute("stroke", color);
              line.setAttribute("stroke-width", "1");
              line.setAttribute("opacity", alpha);
              svg.appendChild(line);
            }
          }
          
          // Draw first rod
          const rod1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
          rod1.setAttribute("x1", pendulum.origin.x);
          rod1.setAttribute("y1", pendulum.origin.y);
          rod1.setAttribute("x2", pos.x1);
          rod1.setAttribute("y2", pos.y1);
          rod1.setAttribute("stroke", color);
          rod1.setAttribute("stroke-width", "3");
          rod1.setAttribute("class", "glow");
          svg.appendChild(rod1);
          
          // Draw second rod
          const rod2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
          rod2.setAttribute("x1", pos.x1);
          rod2.setAttribute("y1", pos.y1);
          rod2.setAttribute("x2", pos.x2);
          rod2.setAttribute("y2", pos.y2);
          rod2.setAttribute("stroke", color);
          rod2.setAttribute("stroke-width", "3");
          rod2.setAttribute("class", "glow");
          svg.appendChild(rod2);
          
          // Draw first bob
          const bob1 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          bob1.setAttribute("cx", pos.x1);
          bob1.setAttribute("cy", pos.y1);
          bob1.setAttribute("r", "12");
          bob1.setAttribute("fill", color);
          bob1.setAttribute("stroke", "#fff");
          bob1.setAttribute("stroke-width", "1");
          bob1.setAttribute("class", "glow");
          svg.appendChild(bob1);
          
          // Draw second bob
          const bob2 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          bob2.setAttribute("cx", pos.x2);
          bob2.setAttribute("cy", pos.y2);
          bob2.setAttribute("r", "8");
          bob2.setAttribute("fill", color);
          bob2.setAttribute("stroke", "#fff");
          bob2.setAttribute("stroke-width", "1");
          bob2.setAttribute("class", "glow");
          svg.appendChild(bob2);
        });
      } catch (error) {
        console.error("Error rendering pendulums:", error);
      }
    }

    function renderOutput() {
      try {
        const outputGrid = document.getElementById("outputGrid");
        outputGrid.innerHTML = "";
        
        const displayBytes = outputList.slice(-150);
        
        displayBytes.forEach((byte, index) => {
          const byteEl = document.createElement("div");
          byteEl.className = "byte";
          byteEl.textContent = byte.toString(16).padStart(2, '0').toUpperCase();
          
          // Highlight recent bytes
          if (index >= displayBytes.length - 5) {
            byteEl.style.background = 'rgba(0, 255, 255, 0.3)';
            byteEl.style.boxShadow = '0 0 5px var(--neon-blue)';
          }
          
          outputGrid.appendChild(byteEl);
        });
      } catch (error) {
        console.error("Error rendering output:", error);
      }
    }

    function updateStats() {
      try {
        // Update entropy
        const entropy = calculateEntropy(outputList);
        const entropyBar = document.getElementById("entropyBar");
        const entropyText = document.getElementById("entropyText");
        
        const entropyPercent = (entropy / 8) * 100;
        entropyBar.style.width = `${entropyPercent}%`;
        entropyText.textContent = `${entropy.toFixed(4)} bits`;
        
        // Update bit distribution
        const bits = outputList.map(b => b.toString(2).padStart(8, '0')).join('');
        const zeros = bits.split('').filter(b => b === '0').length;
        const ones = bits.length - zeros;
        const total = bits.length || 1;
        
        const zerosBar = document.getElementById("zerosBar");
        const onesBar = document.getElementById("onesBar");
        const biasText = document.getElementById("biasText");
        
        const zerosPercent = (zeros / total) * 100;
        const onesPercent = (ones / total) * 100;
        
        zerosBar.style.flex = `${zerosPercent}`;
        onesBar.style.flex = `${onesPercent}`;
        biasText.textContent = `0s: ${zeros} (${zerosPercent.toFixed(1)}%), 1s: ${ones} (${onesPercent.toFixed(1)}%)`;
        
      } catch (error) {
        console.error("Error updating stats:", error);
      }
    }

    function calculateEntropy(data) {
      if (data.length < 2) return 0;
      
      try {
        const freq = {};
        data.forEach(b => freq[b] = (freq[b] || 0) + 1);
        const total = data.length;
        return Object.values(freq)
          .map(f => f / total)
          .reduce((acc, p) => acc - p * Math.log2(p), 0);
      } catch (error) {
        console.error("Error calculating entropy:", error);
        return 0;
      }
    }

    // Initialize when DOM is loaded
    document.addEventListener("DOMContentLoaded", initApplication);
  </script>
</body>
</html>